go语言小知识点
========

### 引用类型

在Go语言中，引用类型有 **切片**, **map**, **接口**, **函数类型**, **chan**

引用类型之所以可以引用，是因为我们创建引用类型的变量，**其实是一个标头值，标头值里包含一个指针，指向底层的数据结构**，当我们在函数中传递引用类型时，其实传递的是这个标头值的副本，它所指向的底层结构并没有被复制传递，这也是引用类型传递高效的原因

> 本质上，我们可以理解函数的传递都是值传递，只不过引用类型传递的是一个指向底层数据的指针，所以我们在操作的时候，可以修改共享的底层数据的值，进而影响到所有引用到这个共享底层数据的变量。


### 结构类型

```go
type person struct {
    age int
    name string
}
```

结构体类型定义好之后，就可以进行使用了，我们可以用过var关键字声明一个结构体类型的变量。

```go
var p person
```

这种声明的方式，会对结构体person里的数据类型默认初始化，也就是使用它们类型的零值，如果要创建一个结构体变量并初始化其为零值时，这种var方式最常用。

如果我们需要指定非零值，就可以使用我们字面量方式了。

```go
jim := person{10,"Jim"}
```

**函数传参是值传递，所以对于结构体来说也不例外，结构体传递的是其本身以及里面的值的拷贝。**

### 自定义类型

自定义类型的方法是基于一个已有的类型，就是基于一个现有的类型创造新的类型，这种也是使用type关键字。

type Duration int64

我们在使用time这个包的时候，对于类型time.Duration应该非常熟悉，它其实就是基于int64 这个基本类型创建的新类型，来表示时间的间隔。

但是这里我们注意，虽然Duration是基于int64创建，觉得他们其实一样，比如都可以使用数字赋值。

```go
type Duration int64

var i Duration = 100
var j int64 = 100
```

**但是本质上，他们并不是同一种类型**，所以对于Go这种强类型语言，他们是不能相互赋值的。

### Go 函数方法

在Go语言中，函数和方法不太一样，有明确的概念区分。其他语言中，比如Java，一般来说，函数就是方法，方法就是函数，但是在Go语言中，函数是指不属于任何结构体、类型的方法，也就是说，函数是没有接收者的；而方法是有接收者的，
我们说的**方法要么是属于一个结构体的，要么属于一个新定义的类型的**

方法的声明和函数类似，他们的区别是：方法在定义的时候，会在func和方法名之间增加一个参数，这个参数就是接收者，这样我们定义的这个方法就和接收者绑定在了一起，称之为这个接收者的方法

Go语言里有两种类型的接收者：**值接收者和指针接收者**

### 接口

接口值内部的布局: 接口的值是一个两个字长度的数据结构.  

第一个字包含一个指向内部表结构的指针，这个内部表里存储的有**实体类型的信息**以及**相关联的方法集**  

第二个字包含的是一个指向存储的**实体类型值**的指针。

所以接口的值结构其实是**两个指针**，这也可以说明接口其实一个引用类型。

#### 方法集

**实体类型以值接收者实现接口的时候，不管是实体类型的值，还是实体类型值的指针，都实现了该接口**

也就是说实现一个接口时, 如果方法的接收者是值类型, 那传参的时候, 可用实体值或实体指针, 也就是相应的实体指针也实现了该接口. 

**实体类型以指针接收者实现接口的时候，只有指向这个类型的指针才被认为实现了该接口**

也就是实现一个接口时, 方法的接收者是指针类型, 那在传参时只能使用指针类型, 不能使用实体类型

| Values | Methods Receivers |
|:-------|:------------------|
| T      | (t T)             |
| *T     | (t T) and (t *T)  |

**类型的值只能实现值接收者的接口；指向类型的指针，既可以实现值接收者的接口，也可以实现指针接收者的接口。**

